const clientId = Math.random().toString(16).substr(2, 6) + '-' + (Date.now() % (2 ** 24)).toString(16);

Tonic.add(class HlsVodToo extends Tonic {
    render () {
        const pathSectors = this.props.path.split('/').filter(_ => _);
        const type = pathSectors.shift();
        const legalPath = pathSectors.join('/');
        switch (type) {
            case 'video':
                return this.html`<hls-vod-video path="${legalPath}"></hls-vod-video>`;
            case 'directory':
                return this.html`<hls-vod-browse path="${legalPath}"></hls-vod-browse>`;
            case 'audio':
                return this.html`<div class="alert alert-danger">Audio feature not implemented.</div>`;
            default:
        }
        window.location.hash = '#/directory/';
    }

    connected() {
        window.addEventListener('hashchange', this.hashChange);
    }

    disconnected() {
        window.removeEventListener('hashchange', this.hashChange);
    }

    constructor() {
        super();
        this.props.path = location.hash.substr(1);
        this.hashChange = () => {
            const path = location.hash.substr(1);
            if (path !== this.props.path) {
                this.reRender(() => ({ path }));
            }
        };
    }
});

Tonic.add(class HlsVodVideo extends Tonic {
    async * render() {
        yield this.html`<div class="alert alert-info">Loading metadata for ${this.props.path}...</div>`;
        let response;
        try {
            response = (await (await fetch(`/video/${encodeURIComponent('/' + this.props.path)}`)).json());
        } catch (e) {
            return this.html`<div class="alert alert-danger">Failed to load metadata: ${e}</div>`;
        }
        if (response.error) {
            return this.html`<div class="alert alert-warning">The file cannot be parsed as a video. You may want to <a href="${'/raw/' + encodeURI(this.props.path)}">download</a> it directly.</div>`;
        }
        return this.html`<hls-vod-video-impl path="${this.props.path}" native="${response.maybeNativelySupported}" buffer-length="${response.bufferLength}"></hls-vod-video-impl>`
    }
});

class Pipe2Jpeg {
    constructor() {
        this.buffer = null;
        this.imageStartPos = -1;
        this.parseHead = -1;
    }

    close() {
        if (this.buffer) {
            console.warn('Extra trailing data.');
        }
        this.buffer = null;
    }

    read(input) {
        const outputs = [];
        
        let buffer;
        if (this.buffer) {
            buffer = new Uint8Array(this.buffer.length + input.length);
            buffer.set(this.buffer);
            buffer.set(input, this.buffer.length);
            this.buffer = null;
        } else {
            buffer = input;
        }

        let finishedAt = 0;
        let index = this.parseHead;
        while ((index = buffer.indexOf(0xff, index + 1)) >= 0) {
            if (index === buffer.length - 1) {
                break;
            }
            const next = buffer[index + 1];
            if (next === 0x00 || next === 0x01 || (next >= 0xD0 && next <= 0xD7)) {
                // Do nothing.
            } else if (next === 0xD8) {
                if (index !== finishedAt) {
                    console.warn('Extra data between JPEGs.');
                }
                if (buffer.length <= index + 4) { 
                    break;
                }
                if (this.imageStartPos >= 0) { throw new Error('Image already started.'); }
                this.imageStartPos = index;
                if (buffer[index + 2] !== 0xff) {
                    console.warn('JPEG not started by a block.');
                }
            } else if (next === 0xD9) {
                if (this.imageStartPos < 0) { throw new Error('Image not started.'); }
                outputs.push(buffer.subarray(this.imageStartPos, index + 2));
                finishedAt = index + 2;
                this.imageStartPos = -1;
            } else {
                if (buffer.length <= index + 4) {
                    break;
                }
                const targetIndex = index + (buffer[index + 2] * 256 + buffer[index + 3]) + 2;
                if (targetIndex >= buffer.length) {
                    break;
                } else {
                    index = targetIndex;
                }
            }
        }

        if (index < 0) { // Finished reading `buffer`.
            index = buffer.length;
        } // Else coming from "break".

        if (buffer.length > finishedAt) {
            this.buffer = buffer.subarray(finishedAt);
            this.imageStartPos -= finishedAt;
            this.parseHead = index - finishedAt - 1;
        } else {
            // this.imageStartPos should already be -1.
            // this.buffer should already be null.
            this.parseHead = -1;
        }
        return outputs.map(arr => new Blob([arr], { type: 'image/jpeg' }));
    }
}

const HlsVodThumbnail_loading = // [ldio] generated by https://loading.io/
`<?xml version="1.0" encoding="utf-8"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="margin: auto; background: rgb(241, 242, 243); display: block; shape-rendering: auto;" width="240px" height="240px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
    <path fill="none" stroke="#93dbe9" stroke-width="10" stroke-dasharray="128.29446411132812 128.29446411132812" d="M24.3 30C11.4 30 5 43.3 5 50s6.4 20 19.3 20c19.3 0 32.1-40 51.4-40 C88.6 30 95 43.3 95 50s-6.4 20-19.3 20C56.4 70 43.6 30 24.3 30z" stroke-linecap="round" style="transform:scale(0.2);transform-origin:50px 50px">
        <animate attributeName="stroke-dashoffset" repeatCount="indefinite" dur="2s" keyTimes="0;1" values="0;256.58892822265625"></animate>
    </path>
</svg>`;

const thumbnailPresets = [[2, 1], [2, 2], [3, 2], [3, 3], [4, 3], [4, 4], [4, 6]];

const loadingPlaceholder = URL.createObjectURL(new Blob([HlsVodThumbnail_loading], { 'type': 'image/svg+xml' }));

Tonic.add(class HlsVodThumbnailImpl extends Tonic {
    renderTable(x, y) {
        const tds = new Array(y);
        for (let i = 0; i < y; i++) {
            tds[i] = new Array(x);
            for (let j = 0; j < x; j++) {
                tds[i][j] = this.props.urls[i * x + j] || loadingPlaceholder;
            }
        }
        return tds.map(tr => this.html`<tr>${tr.map(td => this.html`<td><img src="${td}" /></td>`)}</tr>`);
    }

    renderBlink() {
        return this.html`<tr><td><img class="blink" src="${this.props.urls[0]}" /></td></tr>`;
    }

    updated() {
        const image = this.querySelector('img.blink');
        if (!image) { return; }
        let i = 0;
        this.interval = setInterval(() => {
            i++;
            if (i >= this.props.urls.length) { i = 0; }
            image.src = this.props.urls[i];
        }, 1000);
    }

    disconnected() {
        if (this.interval) { clearInterval(this.interval); }
    }

    render() {
        if (this.interval) { clearInterval(this.interval); }
        const x = this.props.x;
        const y = this.props.y;
        const disabled = x * y > this.props.urls.length;
        const useBlink = !!this.props.blink && !disabled;
        return this.html`
            <table class="table table-bordered mt-4">
                <tbody>
                    ${useBlink ? this.renderBlink() : this.renderTable(x, y)}
                    <tr><td colspan="${useBlink ? '1' : String(this.props.x)}">
                        Num. of images: <div class="btn-group btn-group-toggle">
                            ${thumbnailPresets.map((level, index) => {
                                const checked = (level[0] === x) && (level[1] === y);
                                return this.html`
                                    <label class="${'btn btn-secondary' + (checked ? ' active' : '')}">
                                        <input type="radio" name="numbers" ...${{
                                            checked
                                        }} value="${String(index)}" />${String(level[0] * level[1])}
                                    </label>
                                `;
                            })}
                        </div>
                        <div class="btn-group btn-group-toggle ml-2">
                            <label class="${'btn btn-secondary' + (!useBlink ? ' active' : '')}">
                                <input type="radio" name="mode" ...${{
                                    checked: !useBlink
                                }} value="0" />Grid
                            </label>
                            <label class="${'btn btn-secondary' + (useBlink ? ' active' : '') + (disabled ? ' disabled' : '')}">
                                <input type="radio" name="mode" ...${{
                                    checked: useBlink,
                                    disabled
                                }} value="1" />Blink
                            </label>
                        </div>
                        <button class="btn btn-primary ml-2" data-action="close">Close</button>
                    </td></tr>
                </tbody>
            </table>
        `;
    }

    input(e) {
        if (e.target.name === 'numbers') {
            const config = thumbnailPresets[parseInt(e.target.value)];
            this.parentNode.reRender(props => ({ ...props, x: config[0], y: config[1] }));
        } else if (e.target.name === 'mode') {
            this.reRender(props => ({ ...props, blink: !!parseInt(e.target.value) }));
        }
    }

    click(e) {
        const actionTarget = Tonic.match(e.target, '[data-action]');
        if (!actionTarget) { return; }
        e.preventDefault();
        if (actionTarget.dataset.action === 'close') {
            this.parentNode.reRender(props => ({ ...props, shown: false }));
        }
    }
});

Tonic.add(class HlsVodThumbnail extends Tonic {
    disconnected() {
        if (this.urls) {
            this.urls.forEach(url => URL.revokeObjectURL(url));
            this.urls = null;
        }
    }

    async * render() {
        if (this.urls) {
            this.urls.forEach(url => URL.revokeObjectURL(url));
            delete this.urls;
        }

        const path = this.parentNode.dataset.path;

        if (!this.props.shown || !path) { return ''; }

        const x = this.props.x || 2;
        const y = this.props.y || 2;
        const width = Math.min(640, window.innerWidth / x);

        let template = this.html`<div class="alert alert-info mt-4">Loading thumbnails...</div>`;
        yield template;

        const params = new URLSearchParams();
        params.append('x', x);
        params.append('y', y);
        params.append('width', width);
        params.append('one', 0);
        
        const response = await fetch(`/thumbnail/${encodeURIComponent(path)}?${params.toString()}`);
        const reader = response.body.getReader();

        this.urls = [];
        this.init(reader);
        return this.html`<hls-vod-thumbnail-impl urls="${this.urls}" x="${x}" y="${y}"></hls-vod-thumbnail-impl>`;
    }

    async init(reader) {
        const urls = this.urls;
        const splitter = new Pipe2Jpeg();
        while (true) {
            const result = await reader.read();
            if (urls !== this.urls) {
                reader.cancel();
                return;
            }
            if (result.done) {
                splitter.close();
                break;
            }

            const value = result.value;
            if (!value instanceof Uint8Array) {
                throw new TypeError('Response body of unexpected stream type.');
            }

            let updated = false;
            for (const blob of splitter.read(value)) {
                const src = URL.createObjectURL(blob);
                urls.push(src);
                updated = true;
            }

            if (updated) {
                this.querySelector('hls-vod-thumbnail-impl').reRender(props => ({ ...props, urls }));
            }
        }
    }
});

const HlsVodBrowse_icons = {
    'directory': 'folder',
    'video': 'movie',
    'audio': 'audiotrack',
    'file': 'insert_drive_file'
};

Tonic.add(class HlsVodBrowse extends Tonic {
    async * render() {
        yield this.html`<div class="alert alert-info">Loading directory ${this.props.path}...</div>`;
        let list;
        try {
            list = await (await fetch(`/browse/${encodeURIComponent('/' + this.props.path)}`)).json();
        } catch (e) {
            return this.html`<div class="alert alert-danger">Failed to load directory content: ${e}</div>`;
        }
        const sections = this.props.path.split('/');
        const pathPrefix = this.props.path ? (this.props.path + '/') : '';
        return this.html`
            <nav>
                <ol class="breadcrumb">
                    <li class="${'breadcrumb-item' + (this.props.path.length ? '' : ' active')}"><a href="#/directory/">Home</a></li>
                    ${sections.map((section, index) => 
                        this.html`<li class="${'breadcrumb-item' + ((index === sections.length - 1) ? ' active' : '')}"><a href="${'#/directory/' + encodeURI(sections.slice(0, index + 1).join('/'))}">${section}</a></li>`
                    )}
                </ol>
            </nav>
            <main>
                <ul class="list-group">
                    ${list.map(file => 
                        this.html`<li class="list-group-item" data-path="${pathPrefix + file.name}">
                            <div class="d-flex justify-content-between align-items-center">
                                <a href="${file.type ? `#/${file.type}/${encodeURI(pathPrefix + file.name)}` : '/raw/' + encodeURI(pathPrefix + file.name)}"><span class="material-icons">${HlsVodBrowse_icons[file.type || 'file']}</span>
                                ${file.name}</a>
                                ${(file.type === 'video') ? this.html`<span class="badge badge-secondary" data-action="preview">Preview</span>`: ''}
                            </div>
                        </li>`)}
                </ul>
                <hls-vod-thumbnail></hls-vod-thumbnail>
            </main>
        `;
    }

    click(e) {
        const actionTarget = Tonic.match(e.target, '[data-action]');
        if (!actionTarget) { return; }
        e.preventDefault();
        if (actionTarget.dataset.action === 'preview') {
            const thumbnail = this.querySelector('hls-vod-thumbnail');
            const li = actionTarget.parentNode.parentNode;
            li.appendChild(thumbnail);
            thumbnail.reRender(props => ({ ...props, shown: true }));
        }
    }
});

Tonic.add(class HlsVodVideoImpl extends Tonic {
    connected() { this.maybeReinit(); }

    updated() { this.maybeReinit(); }

    disconnected() {
        if (this.hls) {
            this.hls.destroy();
            this.hls = null;
        }
    }

    maybeReinit() {
        if (this.hls) {
            this.hls.destroy();
            this.hls = null;
        }
        const element = this.querySelector('video.hls');
        const ctrl = this.querySelector('hls-vod-ctrl');
        if (!element) { return; }
        const hls = new Hls({
            maxLength: 10,
            maxMaxBufferLength: this.props.bufferLength
        });
        hls.loadSource(`/hls.${clientId}/${encodeURIComponent(this.props.path)}/master.m3u8`);
        hls.attachMedia(element);
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
            element.play();
            ctrl.reRender(props => ({
                ...props,
                levels: hls.levels.map(level => level.name),
                levelAuto: hls.autoLevelEnabled,
                level: hls.startLevel
            }));
        });
        hls.on(Hls.Events.LEVEL_SWITCHED, (_, data) => {
            ctrl.reRender(props => ({
                ...props,
                levelAuto: hls.autoLevelEnabled,
                level: data.level,
                pending: false
            }));
        });
        hls.on(Hls.Events.ERROR, (_, data) => console.error(data));
        this.hls = hls;
    }
    
    render() {
        if (this.props.native) {
            return this.html`
                <div class="alert alert-info">
                    This browser is directly playing the video file. <a href="#" data-action="switch-to-hls">Switch to HLS</a> if the video cannot be played.
                </div>
                <div class="video-wrap">
                    <video controls src="${'/raw/' + encodeURI(this.props.path)}"></video>
                </div>
            `;
        } else {
            return this.html`
                <div class="video-wrap">
                    <video class="hls" controls></video>
                </div>
                <hls-vod-ctrl></hls-vod-ctrl>
            `;
        }
    }

    click(e) {
        const actionTarget = Tonic.match(e.target, '[data-action]');
        if (!actionTarget) { return; }
        e.preventDefault();
        if (actionTarget.dataset.action === 'switch-to-hls') {
            this.reRender(props => ({ ...props, native: false }));
        }
    }
});

Tonic.add(class HlsVodCtrl extends Tonic {
    render() {
        const levels = this.props.levels || [];
        const activeLevel = this.props.level; // might be undefined which is okay.
        const shown = !!this.props.shown;
        const disabled = !!this.props.pending;
        const auto = !!this.props.levelAuto;
        if (!shown) {
            return this.html`
                <form class="text-center"><a href="#" data-action="flip">Show control</a></form>
            `;
        } else {
            return this.html`
                <form class="text-center">
                    <a href="#" data-action="flip">Hide control</a><br />
                    <div class="btn-group btn-group-toggle">
                        ${levels.map((level, index) => {
                            const checked = (activeLevel === index) && !auto;
                            return this.html`
                                <label class="${'btn btn-secondary' + (checked ? ' active' : '') + (disabled ? ' disabled' : '')}">
                                    <input type="radio" name="quality" ...${{
                                        disabled,
                                        checked
                                    }} value="${String(index)}" />${level}
                                </label>
                            `;
                        })}
                        <label class="${'btn btn-secondary' + (auto ? ' active' : '') + (disabled ? ' disabled' : '')}">
                            <input type="radio" name="quality" ...${{
                                disabled,
                                checked: auto
                            }} value="-1" />Auto ${auto ? ' (' + levels[activeLevel] + ')' : ''}
                        </label>
                    </div>
                </form>
            `;
        }
    }

    click(e) {
        const actionTarget = Tonic.match(e.target, '[data-action]');
        if (!actionTarget) { return; }
        e.preventDefault();
        if (actionTarget.dataset.action === 'flip') {
            this.reRender(props => ({ ...props, shown: !props.shown }));
        }
    }

    input(e) {
        if (e.target.name !== 'quality') { return; }
        const level = parseInt(e.target.value);
        this.reRender((props) => ({ ...props, pending: true }));
        this.parentNode.hls.nextLevel = level;
    }
});